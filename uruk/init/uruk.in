#!/bin/sh
#
# Uruk init script.

# chkconfig: 2345 11 89
# description: starts, stops and saves iptables state, as created by uruk
# beware! above two lines are parsed by chkconfig(8), as commonly found on RPM
# based systems

# for LSB's install_initd and remove_initd, see
# http://refspecs.freestandards.org/LSB_3.1.0/LSB-generic/LSB-generic/initscrcomconv.html
### BEGIN INIT INFO
# Provides:          uruk
# Required-Start:    $network
# Required-Stop:     $network
# Default-Start:     2 3 5
# Default-Stop:      0 6
# Description: Starts uruk firewall configuration
# short-description: uruk firewall configuration
### END INIT INFO

# Copyright (C) 2002, 2003 Laurence J. Lane
# Copyright (C) 2003, 2004, 2005, 2007 Joost van Baal
#
# This file is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# This file is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
#
# You should have received a copy of the GNU GPL along with this file, see
# e.g. the file named COPYING.  If not, see <http://www.gnu.org/licenses/>.

# Based upon /etc/init.d/iptables as shipped with the Debian iptables
# package by Laurence J. Lane

# this file maintained using arch at http://arch.gna.org/uruk/

set -e

# do sanity check on uruk environment.
enable_uruk_check=true

# enable ipv6 support
enable_ipv6=false

# enable calling the unstable uruk-save script
enable_uruk_save=false

# display a warning before each uruk-save call
enable_uruk_save_warning=true

# set enable_autosave to "true" to autosave the active ruleset
# when going from start to stop
enable_autosave=true

# set enable_save_counters to "true" to save table counters with
# rulesets
enable_save_counters=true

PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

# exit code
STATUS=0

# @SYSCONF_PATH@/default/@PACKAGE_TARNAME@ can overrule
# enable_uruk_check, enable_ipv6, enable_autosave, enable_save_counters and PATH
# On Debian systems, configuration for init scripts is in /etc/default/
test -f @SYSCONF_PATH@/default/@PACKAGE_TARNAME@ && . @SYSCONF_PATH@/default/@PACKAGE_TARNAME@
# On Red Hat systems, configuration for init scripts is in /etc/sysconfig/
test -f @SYSCONF_PATH@/sysconfig/@PACKAGE_TARNAME@ && . @SYSCONF_PATH@/sysconfig/@PACKAGE_TARNAME@

#                        /lib/lsb/init-functions
# Red Hat EL AS rel 2.1        No
# Red Hat EL AS rel 3          Yes
#
# Debian GNU/Linux Sarge       Yes, in lsb-base package
#
# See /usr/share/doc/lsb-core/examples/init-skeleton.gz for sample lsb init
# script.  If we wanna be compliant with Red Hat EL AS rel 2.1, we'd need to
# implement our own log_success_msg, log_failure_msg and log_warning_msg.
#
# include lsb functions
lsb_init_functions=/lib/lsb/init-functions
if test -f $lsb_init_functions; then
  . $lsb_init_functions
else
  cat << END
The file $lsb_init_functions is missing from your system.  If you'd like to run
Uruk on a system not conforming to the Linux Standard Base, you're on your own.
Perhaps you can find a file $lsb_init_functions somewhere, or perhaps you could
use uruk without using this init script.
END
  exit 1
fi


initd="$0"

initd_abort_wrong_arg () {
  cmd=$1
  shift
  log_failure_msg "Aborting uruk $cmd: wrong argument: $@"
  exit 2
}

initd_have_a_cow_man () {
  for i in $@; do
    if ! command -v "$i" >/dev/null 2>&1; then
      log_failure_msg "Aborting uruk initd: missing executable $i"
      exit 5
    fi
  done
}

initd_clear () {
  rm -f "$autosave"
  echo -n "Clearing ${iptables_command} ruleset: default ACCEPT policy"
  $iptables_save | sed "/-/d;/^#/d;s/DROP/ACCEPT/" | $iptables_restore
  echo "."
}

initd_halt () {
  rm -f $autosave
  echo -n "Clearing ${iptables_command} ruleset: default DROP policy"
  $iptables_save | sed "/-/d;/^#/d;s/ACCEPT/DROP/" | $iptables_restore
  echo "."
}

initd_flush () {
  # This will NOT flush the mangle or nat table.  If we wanna do that, we'd have to do
  # something like
  #
  #  while read -r table;do iptables -t $table -F;done </proc/net/ip_tables_names
  #
  # However, this won't work for ip6tables; for that we'd have to read ip6_tables_names.
  # We can't use the $iptables_command variable for constructing the name of that file.
  # I give up: this would introduce too much cruft.

  echo -n "Flushing all current $iptables_command rules"
  $iptables_command -F
  echo "."
}

initd_load () {
  ruleset="$libdir/$@"
  if ! test -f "$ruleset"; then
    echo "Can't load ruleset \"$@\": file $ruleset is not present"
    initd_abort_wrong_arg load "unknown ruleset \"$@\""
    if ! test "${ruleset#${libdir}/}" = active -o inactive; then
      usage
    fi
    # FIXME : is this LSB-compliant?
    exit 0
  fi
  if test "${ruleset#${libdir}/}" = inactive; then
    initd_autosave
  fi
  rm -f "$autosave"
  ruleset="$libdir/$@"
  echo -n "Loading ${iptables_command} ruleset: load \"$@\""
  $iptables_restore < "$ruleset"
  STATUS=$?
  echo "."
}

initd_counters () {
  if ! test -d "$libdir"; then
    mkdir -p "$libdir"
  fi
  if test "${enable_save_counters:-false}" = true; then
    echo -n " with counters"
    $iptables_save -c > "$ruleset"
    STATUS=$?
  else
    $iptables_save | sed '/^:/s@\[[0-9]\{1,\}:[0-9]\{1,\}\]@[0:0]@g' > "$ruleset"
    STATUS=$?
  fi
}

initd_save () {
  rm -f $autosave
  ruleset="$libdir/$@"
  echo -n "Saving ${iptables_command} ruleset: save \"$@\""
  initd_counters
  echo "."
}

initd_autosave () {
  if test -f $autosave -a ${enable_autosave-false} = true; then
    ruleset="$libdir/active"
    echo -n "Autosaving ${iptables_command} ruleset: save \"active\""
    initd_counters
    echo "."
  fi
}

initd_active_uruk_save () {
  warn_uruk_save
  if test $iptables_command = ip6tables; then
    echo -n "Saving IPv6 uruk rules as active ruleset"
    uruk-save -6 > "$libdir/active"
    STATUS=$?
    echo "."
  else
    echo -n "Saving IPv4 uruk rules as active ruleset"
    uruk-save > "$libdir/active"
    STATUS=$?
    echo "."
  fi
  initd_load active
  dummy=$?
  test STATUS = 0 && STATUS=$dummy
}

initd_active () {
  if test $enable_uruk_save = true; then
    initd_active_uruk_save
  else
    initd_flush
    if test $iptables_command = ip6tables; then
      echo -n "Loading IPv6 uruk rules"
      # skip all iptables commands in uruk
      URUK_IPTABLES=':' uruk
      STATUS=$?
      echo "."
    else
      echo -n "Loading IPv4 uruk rules"
      # skip all ip6tables commands in uruk
      URUK_IP6TABLES=':' uruk
      STATUS=$?
      echo "."
    fi
    initd_save active
    dummy=$?
    test STATUS = 0 && STATUS=$dummy
  fi
}

initd_start () {
  if ! test -s "$libdir/inactive"; then
    initd_save inactive
  fi
  initd_active
  if test ${enable_autosave-false} = true; then
    touch $autosave
  fi
}

initd_stop () {
  # act sane if inactive state file missing
  ruleset="$libdir/inactive"
  if test -s $ruleset; then
    initd_load inactive
    rm $ruleset
  else
    echo "Uruk not running (no inactive file found)"
    # FIXME: set STATUS here?
  fi
}

usage () {
cat << END
$initd options:
  start
     If not yet done, save current iptables status in "inactive" ruleset.
     (Re)build and load the "active" ruleset.
  save <ruleset>
     Save the current iptables status in given ruleset.
  create <active|inactive>
     create an "active" or "inactive" ruleset with sane defaults: "active"
     will be based upon the uruk rc file.  "inactive" will allow all traffic.
  load <ruleset>
     load a saved ruleset
  reload
     (Re)build and load the "active" ruleset, without temporarily clearing the
     current iptables status.
  force-reload
     (Re)build and load the "active" ruleset.
  stop
     Load the "inactive" ruleset.
  restart
     Perform stop-actions followed by start-actions.
  status
     FIXME
  clear
     Remove all rules and user-defined chains, set default policy to ACCEPT.
  halt
     Remove all rules and user-defined chains, set default policy to DROP.
  flush
     Flush all rules from the current iptables status.

Saved ruleset locations: @LOCALSTATE_PATH@/lib/@PACKAGE_TARNAME@/iptables/ and
@LOCALSTATE_PATH@/lib/@PACKAGE_TARNAME@/ip6tables/ .

END
}

initd_main () {
  case "$1" in
    start)
      initd_start
      if test "$STATUS" = 0; then
        log_success_msg "Starting uruk ($iptables_command)"
      else
        log_failure_msg "Starting uruk ($iptables_command)"
      fi
      ;;
    stop)
      initd_stop
      if test "$STATUS" = 0; then
        log_success_msg "Shutting down uruk ($iptables_command)"
      else
        log_failure_msg "Shutting down uruk ($iptables_command)"
      fi
      ;;
    restart)
      # Restart service (if running) or start service
      $initd stop
      $initd start
      ;;
    force-reload)
      # FIXME does not behave sane when uruk not running!
      initd_active
      if test "$STATUS" = 0; then
        log_success_msg "Reloading uruk ($iptables_command)"
      else
        log_failure_msg "Reloading uruk ($iptables_command)"
      fi
      ;;
    status)
      tmpdir=`mktemp -d /tmp/uruk.$iptables_command.XXXXXXXXXX`
      $iptables_save | grep '^-' > $tmpdir/kernel
      for rule in active inactive; do
        sed -n 's/^\[[0-9]\{1,\}:[0-9]\{1,\}\] //p' $libdir/$rule \
            >$tmpdir/ruleset
        if diff $tmpdir/ruleset $tmpdir/kernel >/dev/null; then
          STATUS=$rule
        fi
      done
      rm -r $tmpdir

      if test "$STATUS" = 0; then
        log_warning_msg "Checking uruk ($iptables_command): No active or inactive uruk rules loaded"
        # 4       program or service status is unknown
        STATUS=4
      else
        log_success_msg "Checking uruk ($iptables_command): $STATUS uruk rules loaded"
        if test "$STATUS" = active; then
          # 0       program is running or service is OK
          STATUS=0
        else
          # 3       program is not running
          STATUS=3
        fi
      fi
      ;;
    # end of LSB required init arguments
    reload)
      if test $enable_uruk_save = true; then
        # FIXME does not behave sane when uruk not running!
        initd_active_uruk_save
      else
        cat <<END
 Either set enable_uruk_save to true in
 @SYSCONF_PATH@/{default,sysconfig}/@PACKAGE_TARNAME@ or call this script with
 the \"force-reload\" option: cannot reload active file without touching your live
 rules if using uruk-save is disallowed."
END
      fi
      ;;
    clear)
      initd_clear
      ;;
    halt)
      initd_halt
      ;;
    flush)
      initd_flush
      ;;
    save)
      shift
      if test -z "$*"; then
        initd_abort_wrong_arg save "no ruleset name given"
      else
        initd_save "$*"
      fi
      ;;
    create)
      shift
      case "$*" in
        active)
          if test $enable_uruk_save = true; then
            warn_uruk_save
            if test $iptables_command = ip6tables; then
              echo -n "Saving IPv6 uruk rules as active ruleset"
              uruk-save -6 > "$libdir/active"
              echo "."
            else
              echo -n "Saving IPv4 uruk rules as active ruleset"
              uruk-save > "$libdir/active"
              echo "."
            fi
          else
            cat <<END
 Either set enable_uruk_save to true in
 @SYSCONF_PATH@/{default,sysconfig}/@PACKAGE_TARNAME@ or call this script with
 the \"start\" option: cannot create active file without touching your live
 rules if using uruk-save is disallowed."
END
          fi
          ;;
        inactive)
          initd_clear
          initd_save inactive
          ;;
        *)
          echo "No sane defaults for \"$*\" known"
          ;;
      esac
      ;;
    load)
      shift
      if test -z "$*"; then
        initd_abort_wrong_arg load "no ruleset name given"
      else
        initd_load "$*"
      fi
      ;;
    *)
      usage
      initd_abort_wrong_arg "$*"
      ;;
  esac
}

initd_preload() {
  iptables="/sbin/${iptables_command}"
  iptables_save="${iptables}-save"
  iptables_restore="${iptables}-restore"
  uruk_config="@SYSCONF_PATH@/@PACKAGE_TARNAME@/rc"
  libdir="@LOCALSTATE_PATH@/lib/@PACKAGE_TARNAME@/${iptables_command}"
  autosave="${libdir}/autosave"
  initd_have_a_cow_man "$iptables_save" "$iptables_restore"
  ${iptables_command} -nL >/dev/null
  initd_main $*
}

check_uruk() {
  initd_have_a_cow_man uruk >/dev/null
  uruk_config="@SYSCONF_PATH@/@PACKAGE_TARNAME@/rc"
  # check for existence of uruk rc file.
  if ! test -r $uruk_config; then
    echo "No file $uruk_config present."
    exit 6
  fi
  # check for sanity of uruk rc file.
  if grep -q URUK_IS_UNCONFIGURED $uruk_config; then
    echo "Uruk is unconfigured.  Please create a sane file $uruk_config.  See uruk(8)."
    exit 6
  fi
}

warn_uruk_save() {
  if test $enable_uruk_save_warning = true; then
    cat <<END
 About to call the uruk-save script.  You should have read the uruk-rc(5)
 manpage.  Your $uruk_config should be sane.  You should NOT be using any hooks
 in your rc file, see uruk-save(8)!  If you don't like all this, read the "Using
 the Uruk init script" part in the GETTING STARTED section of the uruk(8)
 manpage.
END
  fi
}

if test $enable_uruk_check = true; then
  check_uruk
fi

iptables_command=iptables initd_preload $*
if test $enable_ipv6 = true; then
  iptables_command=ip6tables initd_preload $*
fi

exit $STATUS

